import logging
import time

from ..index import Index
from ..selection_algorithm import DEFAULT_PARAMETER_VALUES, SelectionAlgorithm
from ..utils import b_to_mb, mb_to_b

# budget_MB: The algorithm can utilize the specified storage budget in MB.
# max_index_width: The number of columns an index can contain at maximum.
# min_cost_improvement: The value of the relative improvement that must be realized by a
#                       new configuration to be selected.
# The algorithm stops if either the budget is exceeded or no further beneficial
# configurations can be found.
DEFAULT_PARAMETERS = {
    "max_index_num": 4,
    "max_index_width": DEFAULT_PARAMETER_VALUES["max_index_width"],
    "min_cost_improvement": 1.001,
}


# This algorithm is a reimplementation of the Extend heuristic published by Schlosser,
# Kossmann, and Boissier in 2019.
# Details can be found in the original paper:
# Rainer Schlosser, Jan Kossmann, Martin Boissier: Efficient Scalable
# Multi-attribute Index Selection Using Recursive Strategies. ICDE 2019: 1238-1249
class ExtendAlgorithm(SelectionAlgorithm):
    def __init__(self, database_connector, parameters=None):
        if parameters is None:
            parameters = {}
        SelectionAlgorithm.__init__(
            self, database_connector, parameters, DEFAULT_PARAMETERS
        )
        # budget限制
        self.budget = self.parameters["max_index_num"]
        # 最大index宽度
        self.max_index_width = self.parameters["max_index_width"]
        self.workload = None
        # 最小性能提升比例
        self.min_cost_improvement = self.parameters["min_cost_improvement"]

    def _calculate_best_indexes(self, workload):
        logging.info("Calculating best indexes Extend")
        self.workload = workload
        # 获取workload中出现过的column构成的单属性索引集合
        single_attribute_index_candidates = self.workload.potential_indexes()
        # copy单属性索引集合，作为生成多属性索引的后续属性集合
        extension_attribute_candidates = single_attribute_index_candidates.copy()

        # 当前索引集合
        index_combination = []
        # Best index combination during evaluation step
        best = {"combination": [], "reward": 0, "cost": None}

        # 获取当前workload运行开销
        current_cost = self.cost_evaluation.calculate_cost(
            self.workload, index_combination, store_size=True
        )
        # 赋值初始开销
        self.initial_cost = current_cost
        # 当没有任何性能提升，则break
        while True:
            # 筛选budget限制内的单索引候选
            single_attribute_index_candidates = self._get_candidates_within_budget(
                index_combination, single_attribute_index_candidates
            )

            # 单属性索引评估
            for candidate in single_attribute_index_candidates:
                # Only single column index generation
                if candidate not in index_combination:
                    self._evaluate_combination(
                        index_combination + [candidate], best, current_cost
                    )
            # 多属性索引评估
            for attribute in extension_attribute_candidates:
                # Multi-column indexes are generated by attaching columns
                # to existing indexes
                self._attach_to_indexes(index_combination, attribute, best, current_cost)
            if best["reward"] <= 0:
                break

            index_combination = best["combination"]
            logging.debug(
                "Add index. Current cost savings: "
                f"{(1 - best['cost'] / current_cost) * 100:.3f}, "
                f"initial {(1 - best['cost'] / self.initial_cost) * 100:.3f}. "
            )

            best["reward"] = 0
            current_cost = best["cost"]

        return index_combination, 100 * (self.initial_cost - best['cost']) / self.initial_cost

    def _attach_to_indexes(self, index_combination, attribute, best, current_cost):
        assert (
            attribute.is_single_column() is True
        ), "Attach to indexes called with multi column index"

        for position, index in enumerate(index_combination):
            if len(index.columns) >= self.max_index_width:
                continue
            if index.appendable_by(attribute):
                new_index = Index(index.columns + attribute.columns)
                if new_index in index_combination:
                    continue
                new_combination = index_combination.copy()
                # We don't replace, but del and append to keep track of the append order
                del new_combination[position]
                new_combination.append(new_index)
                self._evaluate_combination(
                    new_combination,
                    best,
                    current_cost
                )

    def _get_candidates_within_budget(self, index_combination, candidates):
        new_candidates = []
        if len(index_combination) < self.budget:
            for candidate in candidates:
                new_candidates.append(candidate)
        return new_candidates

    # 评估索引集合
    def _evaluate_combination(
        self, index_combination, best, current_cost
    ):
        # 计算新索引集合下的cost
        cost = self.cost_evaluation.calculate_cost(
            self.workload, index_combination, store_size=True
        )
        # 如果新索引集合带来的性能提升不够，则返回
        if (cost * self.min_cost_improvement) >= current_cost:
            return
        # 计算新索引集合带来的cost下降
        benefit = (current_cost - cost) / current_cost

        # 新的收益比例大于旧的，则更新索引集
        if benefit > best["reward"] and len(index_combination) <= self.budget:
            best["combination"] = index_combination
            best["reward"] = benefit
            best["cost"] = cost

    def rank_indexes(self, indexes):
        initial_cost = self.initial_cost
        indexes_dict = {}
        for index in indexes:
            current_cost = self.cost_evaluation.calculate_cost(
                self.workload, [index], store_size=True
            )
            reward = (initial_cost - current_cost) / initial_cost
            indexes_dict[index] = reward
        sorted_indexes = dict(sorted(indexes_dict.items(), key=lambda item: item[1], reverse=True))
        return list(sorted_indexes.keys())



